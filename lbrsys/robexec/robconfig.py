"""
robconfig.py - configure robot and manage config data
    Manage the itnerface between the robot and a sqlite3
    database describing key attributes, including the
    connections between robot subsytems.
"""

__author__ = "Tal G. Ball"
__copyright__ = "Copyright (C) 2020 Tal G. Ball"
__license__ = "Apache License, Version 2.0"
__version__ = "1.0"

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import sqlite3
import time

from lbrsys.settings import robot_name

class Robconfig:
    def __init__(self, dbfile, name=robot_name):
        self.name = name
        try:
            self.con = sqlite3.connect(dbfile)
        except:
            print('error opening db')

        self.con.row_factory = sqlite3.Row
        self.cursor = self.con.cursor()
        try:
            robrecords = self.cursor.execute(
                "select * from robot where name=?", (self.name,))
            self.robrecord = robrecords.fetchone()
            self.robot_id = self.robrecord['robot_id']

        except:
            print("Exception getting robot config")
            raise

        try:
            processRecords = self.cursor.execute(
                "select distinct robot_process.* from robot_process \
                join channel on (robot_process.process_id = channel.target_process_id \
                or robot_process.process_id = channel.source_process_id) \
                and robot_id = ?",
                (self.robot_id,))

            self.processList = []
            for pr in processRecords:
                prElement = {}
                for k in list(pr.keys()):
                    prElement[k] = pr[k]
                self.processList.append(prElement)              
        except:
            print("Exception getting processes")
            raise

        try:
            channelRecords = self.cursor.execute(
                "select * from channel where robot_id=?",
                (self.robot_id,))

            self.channelList = []
            for cr in channelRecords:
                crElement = {}
                for k in list(cr.keys()):
                    crElement[k] = cr[k]
                self.channelList.append(crElement)
        except:
            print("Exception getting channels")
            raise

        try:
            # message list is not robot-specfic for now
            messageRecords = self.cursor.execute(
                "select * from message")  

            self.messageDict = {}
            for m in messageRecords:
                message = (m['language'], m['text'], m['purpose'], m['type'])
                self.messageDict[m['name']] = message
        except:
            print("Exception getting messages")
            raise

        try:
            self.extcmds = {}
            for c in self.cursor.execute("select * from extcmd where robot_id=?",
                                            (self.robot_id,)):
                self.extcmds[c['cmd_name']] = c
        except:
            print("Exception getting external commands")
            raise


    def saveMessageDict(self, filename='./robmsgdict.py'):
        try:
            dictFile = open(filename, 'w')
        except:
            print("execption opening dictionary file")
            raise

        dictFile.write("# message dictionary\n# Auto Generated by Robconfig: %s\n" %
                       (time.asctime(),))
        dictFile.write("#\n")
        dictFile.write("messageDict = {\n")
        
        m = 1
        l = len(self.messageDict)
        for mkey in self.messageDict:
            if m < l:
                lineEnd = ',\n'
            else:
                lineEnd = '\n\t}\n'
            dictFile.write("\t'%s': %s%s" % (mkey,str(self.messageDict[mkey]),lineEnd))
            m += 1
            
        dictFile.close()

    def noteStarted(self):
        try:
            self.cursor.execute(
                "UPDATE robot \
                SET last_start_time=DATETIME('now','localtime') \
                WHERE name=?",
                (self.name,))
            self.con.commit()
        except:
            print("error noting start time")
            raise
        
    def noteShutdown(self):
        try:
            self.cursor.execute(
                "UPDATE robot \
                SET last_shutdown_time=DATETIME('now','localtime') \
                WHERE name=?",
                (self.name,))
            self.con.commit()
        except:
            print("error noting start time")
            raise
            

if __name__ == '__main__':
    from lbrsys.settings import dbfile
        
    r = Robconfig(dbfile)
    print(r)
    r.saveMessageDict()
    r.noteStarted()
    r.noteShutdown()
    
