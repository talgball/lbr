"""
robconfig.py - configure robot and manage config data
    Manage the interface between the robot and a sqlite3
    database describing key attributes, including the
    connections between robot subsystems.
"""

__author__ = "Tal G. Ball"
__copyright__ = "Copyright (C) 2020 Tal G. Ball"
__license__ = "Apache License, Version 2.0"
__version__ = "1.0"

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import sqlite3
import time


from lbrsys.settings import robot_name

class Robconfig:
    def __init__(self, dbfile, name=robot_name):
        self.name = name
        try:
            self.con = sqlite3.connect(dbfile)
        except:
            print('error opening db')

        self.con.row_factory = sqlite3.Row
        self.cursor = self.con.cursor()
        try:
            robrecords = self.cursor.execute(
                "select * from robot where name=?", (self.name,))
            self.robrecord = robrecords.fetchone()
            self.robot_id = self.robrecord['robot_id']

        except:
            print("Exception getting robot config")
            raise

        try:
            processRecords = self.cursor.execute(
                "select distinct robot_process.* from robot_process \
                join channel on (robot_process.process_id = channel.target_process_id \
                or robot_process.process_id = channel.source_process_id) \
                and robot_id = ?",
                (self.robot_id,))

            self.processList = []
            for pr in processRecords:
                prElement = {}
                for k in list(pr.keys()):
                    prElement[k] = pr[k]
                self.processList.append(prElement)              
        except:
            print("Exception getting processes")
            raise

        try:
            channelRecords = self.cursor.execute(
                "select * from channel where robot_id=?",
                (self.robot_id,))

            self.channelList = []
            for cr in channelRecords:
                crElement = {}
                for k in list(cr.keys()):
                    crElement[k] = cr[k]
                self.channelList.append(crElement)
        except:
            print("Exception getting channels")
            raise

        try:
            # message list is not robot-specfic for now
            # todo normalize the message data model accross language
            messageRecords = self.cursor.execute(
                "select * from message order by name")

            # todo generalize vs schema
            self.messageDict = {}
            for m in messageRecords:
                message = {'text': m['text'],
                           'purpose': m['purpose'],
                           'type': m['type'],
                           }

                if m['name'] not in self.messageDict:
                    self.messageDict[m['name']] = {}

                self.messageDict[m['name']][m['language']] = message
        except:
            print("Exception getting messages")
            raise

        try:
            self.extcmds = {}
            for c in self.cursor.execute("select * from extcmd where robot_id=?",
                                            (self.robot_id,)):
                self.extcmds[c['cmd_name']] = c
        except:
            print("Exception getting external commands")
            raise


    def saveMessageDict(self, filename='./robmsgdict.py'):
        with open(filename, 'w') as dictFile:
            dictFile.write("# Slightly silly message dictionary\n# Auto Generated by robconfig at %s\n" %
                           (time.asctime(),))
            dictFile.write("#\n")
            dictFile.write("\nmessageDict = {\n")
            for m in self.messageDict.keys():
                dictFile.write("'%s': %s, \n" % (m, self.messageDict[m]))
            dictFile.write("}\n")


    def noteStarted(self):
        try:
            self.cursor.execute(
                "UPDATE robot \
                SET last_start_time=DATETIME('now', 'localtime') \
                WHERE name=?",
                (self.name,))
            self.con.commit()
        except:
            print("error noting start time")
            raise
        
    def noteShutdown(self):
        try:
            self.cursor.execute(
                "UPDATE robot \
                SET last_shutdown_time=DATETIME('now', 'localtime') \
                WHERE name=?",
                (self.name,))
            self.con.commit()
        except:
            print("error noting start time")
            raise
            

if __name__ == '__main__':
    from lbrsys.settings import dbfile
        
    r = Robconfig(dbfile)
    print(r)
    r.saveMessageDict()
    r.noteStarted()
    r.noteShutdown()
    
